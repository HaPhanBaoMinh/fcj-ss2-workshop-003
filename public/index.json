[
{
	"uri": "//localhost:1313/1-prepare_resource/1.1-esp34/",
	"title": "Cài đặt ESP32",
	"tags": [],
	"description": "",
	"content": "\nWOKWI Trong bài lab này, chúng ta sẽ sử dụng Wokwi để mô phỏng việc thu thập dữ liệu từ cảm biến nhiệt độ và độ ẩm DHT11 và gửi dữ liệu lên AWS IoT Core thông qua giao thức MQTT.\nSetup thiết bị Sau khi đã ta đã có tài khoản trên Wokwi, chúng ta tiến hành tạo một project mới.\nTruy cập vào trang chủ của Wokwi: https://wokwi.com/ Đăng nhập vào tài khoản của bạn. Tạo một project mới bằng cách chọn New Project. Chọn ESP32 từ danh sách các linh kiện. Chọn MicroPython. Chọn diagram.json và paste nội dung sau vào: { \u0026#34;version\u0026#34;: 1, \u0026#34;author\u0026#34;: \u0026#34;Anonymous maker\u0026#34;, \u0026#34;editor\u0026#34;: \u0026#34;wokwi\u0026#34;, \u0026#34;parts\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;wokwi-esp32-devkit-v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;esp\u0026#34;, \u0026#34;top\u0026#34;: 137.33, \u0026#34;left\u0026#34;: -18.01, \u0026#34;rotate\u0026#34;: 270, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-lcd1602\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;lcd1\u0026#34;, \u0026#34;top\u0026#34;: 18.67, \u0026#34;left\u0026#34;: 76, \u0026#34;attrs\u0026#34;: { \u0026#34;pins\u0026#34;: \u0026#34;i2c\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r1\u0026#34;, \u0026#34;top\u0026#34;: 113.34, \u0026#34;left\u0026#34;: -106.01, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r2\u0026#34;, \u0026#34;top\u0026#34;: 130.67, \u0026#34;left\u0026#34;: -106.68, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-dht22\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;dht1\u0026#34;, \u0026#34;top\u0026#34;: 182.7, \u0026#34;left\u0026#34;: 205.8, \u0026#34;attrs\u0026#34;: {} } ], \u0026#34;connections\u0026#34;: [ [ \u0026#34;esp:TX0\u0026#34;, \u0026#34;$serialMonitor:RX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;esp:RX0\u0026#34;, \u0026#34;$serialMonitor:TX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;lcd1:SCL\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:SDA\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;h-30\u0026#34;, \u0026#34;v103\u0026#34;, \u0026#34;h41\u0026#34; ] ], [ \u0026#34;lcd1:GND\u0026#34;, \u0026#34;esp:GND.1\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;h-39\u0026#34;, \u0026#34;v123\u0026#34;, \u0026#34;h31\u0026#34; ] ], [ \u0026#34;r2:2\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v1\u0026#34;, \u0026#34;h9\u0026#34; ] ], [ \u0026#34;r1:2\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h37\u0026#34; ] ], [ \u0026#34;r2:1\u0026#34;, \u0026#34;r1:1\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;r1:1\u0026#34;, \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;dht1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h-19.2\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-105.6\u0026#34; ] ], [ \u0026#34;dht1:SDA\u0026#34;, \u0026#34;esp:D15\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v9.6\u0026#34;, \u0026#34;h-38.3\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-119.01\u0026#34; ] ], [ \u0026#34;dht1:GND\u0026#34;, \u0026#34;esp:GND.2\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;v19.2\u0026#34;, \u0026#34;h-172.8\u0026#34; ] ] ], \u0026#34;dependencies\u0026#34;: {} } Kết quả: "
},
{
	"uri": "//localhost:1313/1-prepare_resource/",
	"title": "Chuẩn bị tài nguyên",
	"tags": [],
	"description": "",
	"content": "\nSơ đồ tổng quan Sơ đồ trên là sơ đồ tổng quan về bài lab này.\nESP32 sẽ thu thập thông tin về nhiệt độ và độ ẩm từ cảm biến. ESP32 sẽ gửi thông tin thu thập được lên Service AWS IoT Core thông qua giao thức MQTT với topic tương ứng, ở đây topic sẽ được chia theo cấu trúc device_id/sensor_id. Sau khi nhận được thông tin từ ESP32, AWS IoT Core sẽ gửi thông tin đó đến AWS Lambda để xử lý. AWS Lambda sẽ lưu thông tin nhận được vào DynamoDB. Sau một khoảng thời gian chúng ta sẽ sử dụng dữ liệu trong DynamoDB để import vào Amazon SageMaker Canvas để vẽ biểu đồ và dự đoán nhiệt độ và độ ẩm. Thông tin về resourre Toàn bộ thông tin setup wokwi và code mình sẽ để ở đây: Tài nguyên\n"
},
{
	"uri": "//localhost:1313/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Dự Đoán Nhiệt Độ \u0026amp; Độ Ẩm Từ Dữ Liệu ESP32 qua IoT Core 1. Overview Trong bài viết này, chúng ta sẽ tìm hiểu cách sử dụng ESP32 để đo nhiệt độ và độ ẩm từ cảm biến nhiệt độ, độ ẩm, sau đó gửi dữ liệu lên AWS IOT CORE và lưu trữ vào DynamoDB. Sau đó chúng ta sẽ dùng Lambda để chuẩn hóa dữ liệu. Cuối cùng, chúng ta sẽ sử dụng AWS SageMaker Canvas để tiến hành dự đoán nhiệt độ và độ ẩm trong tương lai.\nBài Lab này có thể ứng dụng trong nhiều lĩnh vực như: nông nghiệp, y tế, công nghiệp, \u0026hellip;\n2. Objectives Hiểu cách sử dụng ESP32 để đo nhiệt độ và độ ẩm từ cảm biến nhiệt độ, độ ẩm Hiểu cách gửi dữ liệu lên AWS IOT CORE và lưu trữ vào DynamoDB Hiểu cách sử dụng Lambda để chuẩn hóa dữ liệu Hiểu cách sử dụng AWS SageMaker Canvas để tiến hành dự đoán nhiệt độ và độ ẩm trong tương lai 3. Content 1. Chuẩn bị các tài nguyên cần thiết 2. Cài đặt ESP32 3. Gửi dữ liệu lên AWS IOT CORE 4. Lưu trữ dữ liệu vào DynamoDB 5. Chuẩn hóa dữ liệu bằng Lambda 6. Dự đoán nhiệt độ và độ ẩm bằng SageMaker Canvas 7. Kết luận và xóa các service "
},
{
	"uri": "//localhost:1313/1-prepare_resource/1.2-library/",
	"title": "Các thư viện cần thiết",
	"tags": [],
	"description": "",
	"content": "\nCác file code để giao tiếp với màn hình. Chúng ta tạo một file i2c_lcd.py: \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C. This was tested with: https://www.wemos.cc/product/d1-mini.html\u0026#34;\u0026#34;\u0026#34; from lcd_api import LcdApi from machine import I2C from time import sleep_ms # The PCF8574 has a jumper selectable address: 0x20 - 0x27 #DEFAULT_I2C_ADDR = 0x20 # Defines shifts or masks for the various LCD line attached to the PCF8574 MASK_RS = 0x01 MASK_RW = 0x02 MASK_E = 0x04 SHIFT_BACKLIGHT = 3 SHIFT_DATA = 4 class I2cLcd(LcdApi): \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C.\u0026#34;\u0026#34;\u0026#34; def __init__(self, i2c, i2c_addr, num_lines, num_columns): self.i2c = i2c self.i2c_addr = i2c_addr self.i2c.writeto(self.i2c_addr, bytearray([0])) sleep_ms(20) # Allow LCD time to powerup # Send reset 3 times self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(5) # need to delay at least 4.1 msec self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) # Put LCD into 4 bit mode self.hal_write_init_nibble(self.LCD_FUNCTION) sleep_ms(1) LcdApi.__init__(self, num_lines, num_columns) cmd = self.LCD_FUNCTION if num_lines \u0026gt; 1: cmd |= self.LCD_FUNCTION_2LINES self.hal_write_command(cmd) def hal_write_init_nibble(self, nibble): \u0026#34;\u0026#34;\u0026#34;Writes an initialization nibble to the LCD. This particular function is only used during initialization. \u0026#34;\u0026#34;\u0026#34; byte = ((nibble \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([1 \u0026lt;\u0026lt; SHIFT_BACKLIGHT])) def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([0])) def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Writes a command to the LCD. Data is latched on the falling edge of E. \u0026#34;\u0026#34;\u0026#34; byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((cmd \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((cmd \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) if cmd \u0026lt;= 3: # The home and clear commands require a worst case delay of 4.1 msec sleep_ms(5) def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD.\u0026#34;\u0026#34;\u0026#34; byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((data \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((data \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) Chúng ta tạo một file lcd_api.py: \u0026#34;\u0026#34;\u0026#34;Provides an API for talking to HD44780 compatible character LCDs.\u0026#34;\u0026#34;\u0026#34; import time class LcdApi: \u0026#34;\u0026#34;\u0026#34;Implements the API for talking with HD44780 compatible character LCDs. This class only knows what commands to send to the LCD, and not how to get them to the LCD. It is expected that a derived class will implement the hal_xxx functions. \u0026#34;\u0026#34;\u0026#34; # The following constant names were lifted from the avrlib lcd.h # header file, however, I changed the definitions from bit numbers # to bit masks. # # HD44780 LCD controller command set LCD_CLR = 0x01 # DB0: clear display LCD_HOME = 0x02 # DB1: return to home position LCD_ENTRY_MODE = 0x04 # DB2: set entry mode LCD_ENTRY_INC = 0x02 # --DB1: increment LCD_ENTRY_SHIFT = 0x01 # --DB0: shift LCD_ON_CTRL = 0x08 # DB3: turn lcd/cursor on LCD_ON_DISPLAY = 0x04 # --DB2: turn display on LCD_ON_CURSOR = 0x02 # --DB1: turn cursor on LCD_ON_BLINK = 0x01 # --DB0: blinking cursor LCD_MOVE = 0x10 # DB4: move cursor/display LCD_MOVE_DISP = 0x08 # --DB3: move display (0-\u0026gt; move cursor) LCD_MOVE_RIGHT = 0x04 # --DB2: move right (0-\u0026gt; left) LCD_FUNCTION = 0x20 # DB5: function set LCD_FUNCTION_8BIT = 0x10 # --DB4: set 8BIT mode (0-\u0026gt;4BIT mode) LCD_FUNCTION_2LINES = 0x08 # --DB3: two lines (0-\u0026gt;one line) LCD_FUNCTION_10DOTS = 0x04 # --DB2: 5x10 font (0-\u0026gt;5x7 font) LCD_FUNCTION_RESET = 0x30 # See \u0026#34;Initializing by Instruction\u0026#34; section LCD_CGRAM = 0x40 # DB6: set CG RAM address LCD_DDRAM = 0x80 # DB7: set DD RAM address LCD_RS_CMD = 0 LCD_RS_DATA = 1 LCD_RW_WRITE = 0 LCD_RW_READ = 1 def __init__(self, num_lines, num_columns): self.num_lines = num_lines if self.num_lines \u0026gt; 4: self.num_lines = 4 self.num_columns = num_columns if self.num_columns \u0026gt; 40: self.num_columns = 40 self.cursor_x = 0 self.cursor_y = 0 self.implied_newline = False self.backlight = True self.display_off() self.backlight_on() self.clear() self.hal_write_command(self.LCD_ENTRY_MODE | self.LCD_ENTRY_INC) self.hide_cursor() self.display_on() def clear(self): \u0026#34;\u0026#34;\u0026#34;Clears the LCD display and moves the cursor to the top left corner. \u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_CLR) self.hal_write_command(self.LCD_HOME) self.cursor_x = 0 self.cursor_y = 0 def show_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be made visible.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def hide_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be hidden.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def blink_cursor_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it blink.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR | self.LCD_ON_BLINK) def blink_cursor_off(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it no blink (i.e. be solid).\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def display_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on (i.e. unblanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def display_off(self): \u0026#34;\u0026#34;\u0026#34;Turns off (i.e. blanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL) def backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight on. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = True self.hal_backlight_on() def backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight off. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = False self.hal_backlight_off() def move_to(self, cursor_x, cursor_y): \u0026#34;\u0026#34;\u0026#34;Moves the cursor position to the indicated position. The cursor position is zero based (i.e. cursor_x == 0 indicates first column). \u0026#34;\u0026#34;\u0026#34; self.cursor_x = cursor_x self.cursor_y = cursor_y addr = cursor_x \u0026amp; 0x3f if cursor_y \u0026amp; 1: addr += 0x40 # Lines 1 \u0026amp; 3 add 0x40 if cursor_y \u0026amp; 2: # Lines 2 \u0026amp; 3 add number of columns addr += self.num_columns self.hal_write_command(self.LCD_DDRAM | addr) def putchar(self, char): \u0026#34;\u0026#34;\u0026#34;Writes the indicated character to the LCD at the current cursor position, and advances the cursor by one position. \u0026#34;\u0026#34;\u0026#34; if char == \u0026#39;\\n\u0026#39;: if self.implied_newline: # self.implied_newline means we advanced due to a wraparound, # so if we get a newline right after that we ignore it. pass else: self.cursor_x = self.num_columns else: self.hal_write_data(ord(char)) self.cursor_x += 1 if self.cursor_x \u0026gt;= self.num_columns: self.cursor_x = 0 self.cursor_y += 1 self.implied_newline = (char != \u0026#39;\\n\u0026#39;) if self.cursor_y \u0026gt;= self.num_lines: self.cursor_y = 0 self.move_to(self.cursor_x, self.cursor_y) def putstr(self, string): \u0026#34;\u0026#34;\u0026#34;Write the indicated string to the LCD at the current cursor position and advances the cursor position appropriately. \u0026#34;\u0026#34;\u0026#34; for char in string: self.putchar(char) def custom_char(self, location, charmap): \u0026#34;\u0026#34;\u0026#34;Write a character to one of the 8 CGRAM locations, available as chr(0) through chr(7). \u0026#34;\u0026#34;\u0026#34; location \u0026amp;= 0x7 self.hal_write_command(self.LCD_CGRAM | (location \u0026lt;\u0026lt; 3)) self.hal_sleep_us(40) for i in range(8): self.hal_write_data(charmap[i]) self.hal_sleep_us(40) self.move_to(self.cursor_x, self.cursor_y) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Write a command to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_sleep_us(self, usecs): \u0026#34;\u0026#34;\u0026#34;Sleep for some time (given in microseconds).\u0026#34;\u0026#34;\u0026#34; time.sleep_us(usecs) Tạo một file main.py để test: import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;micropython-weather-demo\u0026#34; MQTT_BROKER = \u0026#34;broker.mqttdashboard.com\u0026#34; MQTT_USER = \u0026#34;\u0026#34; MQTT_PASSWORD = \u0026#34;\u0026#34; MQTT_TOPIC = \u0026#34;wokwi-weather\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER, user=MQTT_USER, password=MQTT_PASSWORD) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings if message != prev_weather: print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message else: print(\u0026#34;No change\u0026#34;) time.sleep(2) Chúng ta sẽ được kết quả như sau:\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]