[
{
	"uri": "//localhost:1313/1-prepare_resource/1.1-esp34/",
	"title": "Cài đặt ESP32",
	"tags": [],
	"description": "",
	"content": "\nWOKWI Trong bài lab này, chúng ta sẽ sử dụng Wokwi để mô phỏng việc thu thập dữ liệu từ cảm biến nhiệt độ và độ ẩm DHT11 và gửi dữ liệu lên AWS IoT Core thông qua giao thức MQTT.\nSetup thiết bị Sau khi đã ta đã có tài khoản trên Wokwi, chúng ta tiến hành tạo một project mới.\nTruy cập vào trang chủ của Wokwi: https://wokwi.com/ Đăng nhập vào tài khoản của bạn. Tạo một project mới bằng cách chọn New Project. Chọn ESP32 từ danh sách các linh kiện. Chọn MicroPython. Chọn diagram.json và paste nội dung sau vào: { \u0026#34;version\u0026#34;: 1, \u0026#34;author\u0026#34;: \u0026#34;Anonymous maker\u0026#34;, \u0026#34;editor\u0026#34;: \u0026#34;wokwi\u0026#34;, \u0026#34;parts\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;wokwi-esp32-devkit-v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;esp\u0026#34;, \u0026#34;top\u0026#34;: 137.33, \u0026#34;left\u0026#34;: -18.01, \u0026#34;rotate\u0026#34;: 270, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-lcd1602\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;lcd1\u0026#34;, \u0026#34;top\u0026#34;: 18.67, \u0026#34;left\u0026#34;: 76, \u0026#34;attrs\u0026#34;: { \u0026#34;pins\u0026#34;: \u0026#34;i2c\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r1\u0026#34;, \u0026#34;top\u0026#34;: 113.34, \u0026#34;left\u0026#34;: -106.01, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r2\u0026#34;, \u0026#34;top\u0026#34;: 130.67, \u0026#34;left\u0026#34;: -106.68, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-dht22\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;dht1\u0026#34;, \u0026#34;top\u0026#34;: 182.7, \u0026#34;left\u0026#34;: 205.8, \u0026#34;attrs\u0026#34;: {} } ], \u0026#34;connections\u0026#34;: [ [ \u0026#34;esp:TX0\u0026#34;, \u0026#34;$serialMonitor:RX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;esp:RX0\u0026#34;, \u0026#34;$serialMonitor:TX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;lcd1:SCL\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:SDA\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;h-30\u0026#34;, \u0026#34;v103\u0026#34;, \u0026#34;h41\u0026#34; ] ], [ \u0026#34;lcd1:GND\u0026#34;, \u0026#34;esp:GND.1\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;h-39\u0026#34;, \u0026#34;v123\u0026#34;, \u0026#34;h31\u0026#34; ] ], [ \u0026#34;r2:2\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v1\u0026#34;, \u0026#34;h9\u0026#34; ] ], [ \u0026#34;r1:2\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h37\u0026#34; ] ], [ \u0026#34;r2:1\u0026#34;, \u0026#34;r1:1\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;r1:1\u0026#34;, \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;dht1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h-19.2\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-105.6\u0026#34; ] ], [ \u0026#34;dht1:SDA\u0026#34;, \u0026#34;esp:D15\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v9.6\u0026#34;, \u0026#34;h-38.3\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-119.01\u0026#34; ] ], [ \u0026#34;dht1:GND\u0026#34;, \u0026#34;esp:GND.2\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;v19.2\u0026#34;, \u0026#34;h-172.8\u0026#34; ] ] ], \u0026#34;dependencies\u0026#34;: {} } Kết quả: "
},
{
	"uri": "//localhost:1313/1-prepare_resource/",
	"title": "Chuẩn bị",
	"tags": [],
	"description": "",
	"content": "\nSơ đồ tổng quan Sơ đồ trên là sơ đồ tổng quan về bài lab này.\nESP32 sẽ thu thập thông tin về nhiệt độ và độ ẩm từ cảm biến. ESP32 sẽ gửi thông tin thu thập được lên Service AWS IoT Core thông qua giao thức MQTT với topic tương ứng, ở đây topic sẽ được chia theo cấu trúc device_id/sensor_id. Sau khi nhận được thông tin từ ESP32, AWS IoT Core sẽ gửi thông tin đó đến AWS Lambda để xử lý. AWS Lambda sẽ lưu thông tin nhận được vào DynamoDB. Sau một khoảng thời gian chúng ta sẽ sử dụng dữ liệu trong DynamoDB để import vào Amazon SageMaker Canvas để vẽ biểu đồ và dự đoán nhiệt độ và độ ẩm. Thông tin về resourre Toàn bộ thông tin setup wokwi và code mình sẽ để ở đây: Tài nguyên\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.1-create_dataset/",
	"title": "Chuẩn bị dataset",
	"tags": [],
	"description": "",
	"content": "Trước khi chúng ta bắt đầu xây dựng mô hình machine learning, chúng ta cần chuẩn bị dataset cho mô hình của mình.\nTừ dữ liệu mẫu mà chúng ta đã import vào DynamoDB, chúng ta sẽ sử dụng dữ liệu này để xây dựng mô hình machine learning.\nĐầu tiên chúng ta phải export dữ liệu từ DynamoDB ra file CSV như mình đã hướng dẫn ở step 4.\n1. Tạo dataset Chúng ta vào Sagemaker và chọn Datasets sau đó chọn Import data.\nChúng ta chọn Tabular và tiến hành chọn file CSV mà chúng ta đã export từ DynamoDB.\nChúng ta có thể preview dữ liệu trước khi import.\nTiến hành Create dataset.\nKiểm tra lại ở trang Datasets chúng ta đã tạo được dataset.\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.1-register_new_thing/",
	"title": "Đăng kí thiết bị",
	"tags": [],
	"description": "",
	"content": "Bước đầu tiên để sử dụng AWS IoT Core là chúng ta cần đăng kí một thiết bị. Trong trường hợp của chúng ta thì đó là ESP32.\n1. Chúng ta tuy cập vào AWS IoT Core và chọn Create thing. 2. Điền thông tin về thiết bị của bạn. Ở đây mình điền thông tin như sau: Ở đây ngoài tên thì còn có nhiều thông tin khác như:\nThing type: Loại thiết bị. Thing group: Nhóm thiết bị. Billing group: Nhóm thanh toán. Packages and versions: Phiên bản và gói. Những thông tin này sẽ giúp bạn quản lý thiết bị của mình một cách dễ dàng hơn trong trường hợp bạn có nhiều thiết bị.\nỞ đây mình điền tên thiết bị + mã số thiết bị.\nSau đó các bạn chọn Next.\n3. Tạo Certificates. Để đảm bảo thông tin gửi đi và nhận về an toàn, chúng ta cần tạo Certificates cho thiết bị.\nỞ đây mình chọn Auto-generate a new certificate và chọn Next.\n4. Attach a policy. Chúng ta sẽ tạo policy sau, ở bước này chúng ta chọn Create thing\n5. Sau khi tạo chúng ta hãy tải các file Certificates về máy. "
},
{
	"uri": "//localhost:1313/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Dự Đoán Nhiệt Độ \u0026amp; Độ Ẩm Từ Dữ Liệu ESP32 qua IoT Core 1. Overview Trong bài viết này, chúng ta sẽ tìm hiểu cách sử dụng ESP32 để đo nhiệt độ và độ ẩm từ cảm biến nhiệt độ, độ ẩm, sau đó gửi dữ liệu lên AWS IOT CORE và lưu trữ vào DynamoDB. Sau đó chúng ta sẽ dùng Lambda để chuẩn hóa dữ liệu. Cuối cùng, chúng ta sẽ sử dụng AWS SageMaker Canvas để tiến hành dự đoán nhiệt độ và độ ẩm trong tương lai.\nBài Lab này có thể ứng dụng trong nhiều lĩnh vực như: nông nghiệp, y tế, công nghiệp, \u0026hellip;\n2. Objectives Hiểu cách sử dụng ESP32 để đo nhiệt độ và độ ẩm từ cảm biến nhiệt độ, độ ẩm Hiểu cách gửi dữ liệu lên AWS IOT CORE và lưu trữ vào DynamoDB Hiểu cách sử dụng Lambda để chuẩn hóa dữ liệu Hiểu cách sử dụng AWS SageMaker Canvas để tiến hành dự đoán nhiệt độ và độ ẩm trong tương lai 3. Content 1. Chuẩn bị các tài nguyên cần thiết 2. Cài đặt ESP32 3. Gửi dữ liệu lên AWS IOT CORE 4. Lưu trữ dữ liệu vào DynamoDB 5. Chuẩn hóa dữ liệu bằng Lambda 6. Dự đoán nhiệt độ và độ ẩm bằng SageMaker Canvas 7. Kết luận và xóa các service "
},
{
	"uri": "//localhost:1313/3-store_data/3.1-create_dynamodb/",
	"title": "Tạo bảng trong DynamoDB",
	"tags": [],
	"description": "",
	"content": "Sau khi các thiết bị IoT của chúng ta gửi data lên cho IoT core chúng ta sẽ tiến hành lưu các thông tin này lại, có nhiều các để lưu trữ thông tin này, ở đây mình dùng DynamoDb để lưu trữ các dữ liệu trên.\n1. Tạo bảng trong DynamoDB Tiến hành chọn Create table để tạo bảng mới.\n2. Điền các thông tin cần thiết Table name: Tên bảng mà bạn muốn tạo. Primary key: Chọn kiểu key cho bảng, ở đây mình chọn Partition key là device_id. Add sort key: Nếu bạn muốn thêm sort key thì chọn vào đây, ở đây mình để là timestamp Sau đó tiến hành chọn Create để tạo bảng.\nChúng ta được bảng như sau:\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/",
	"title": "AWS IoT Core",
	"tags": [],
	"description": "",
	"content": "\nAWS IoT Core là một service cung cấp các dịch vụ cho phép kết nối các thiết bị IoT với các service khác của AWS.\nIoT Core hỗ trợ nhiều giao thức kết nối khác nhau như:\n1. MQTT (Message Queuing and Telemetry Transport)\n2. MQTT over WSS (Websockets Secure)\n3. WebSockets\n4. HTTPS (Hypertext Transfer Protocol - Secure)\n5. LoRaWAN (Long Range Wide Area Network)\nCách kết nối thiết bị với IoT Core:\nAWS IoT Device SDK AWS IoT Core for LoRaWAN AWS Command Line Interface (CLI) AWS IoT API AWS SDKs Ngoài ra bạn cũng có thể gửi trực tiếp message vào message broker trên AWS Console.\n"
},
{
	"uri": "//localhost:1313/1-prepare_resource/1.2-library/",
	"title": "Các thư viện cần thiết",
	"tags": [],
	"description": "",
	"content": "\nCác file code để giao tiếp với màn hình. Chúng ta tạo một file i2c_lcd.py: \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C. This was tested with: https://www.wemos.cc/product/d1-mini.html\u0026#34;\u0026#34;\u0026#34; from lcd_api import LcdApi from machine import I2C from time import sleep_ms # The PCF8574 has a jumper selectable address: 0x20 - 0x27 #DEFAULT_I2C_ADDR = 0x20 # Defines shifts or masks for the various LCD line attached to the PCF8574 MASK_RS = 0x01 MASK_RW = 0x02 MASK_E = 0x04 SHIFT_BACKLIGHT = 3 SHIFT_DATA = 4 class I2cLcd(LcdApi): \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C.\u0026#34;\u0026#34;\u0026#34; def __init__(self, i2c, i2c_addr, num_lines, num_columns): self.i2c = i2c self.i2c_addr = i2c_addr self.i2c.writeto(self.i2c_addr, bytearray([0])) sleep_ms(20) # Allow LCD time to powerup # Send reset 3 times self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(5) # need to delay at least 4.1 msec self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) # Put LCD into 4 bit mode self.hal_write_init_nibble(self.LCD_FUNCTION) sleep_ms(1) LcdApi.__init__(self, num_lines, num_columns) cmd = self.LCD_FUNCTION if num_lines \u0026gt; 1: cmd |= self.LCD_FUNCTION_2LINES self.hal_write_command(cmd) def hal_write_init_nibble(self, nibble): \u0026#34;\u0026#34;\u0026#34;Writes an initialization nibble to the LCD. This particular function is only used during initialization. \u0026#34;\u0026#34;\u0026#34; byte = ((nibble \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([1 \u0026lt;\u0026lt; SHIFT_BACKLIGHT])) def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([0])) def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Writes a command to the LCD. Data is latched on the falling edge of E. \u0026#34;\u0026#34;\u0026#34; byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((cmd \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((cmd \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) if cmd \u0026lt;= 3: # The home and clear commands require a worst case delay of 4.1 msec sleep_ms(5) def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD.\u0026#34;\u0026#34;\u0026#34; byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((data \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((data \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) Chúng ta tạo một file lcd_api.py: \u0026#34;\u0026#34;\u0026#34;Provides an API for talking to HD44780 compatible character LCDs.\u0026#34;\u0026#34;\u0026#34; import time class LcdApi: \u0026#34;\u0026#34;\u0026#34;Implements the API for talking with HD44780 compatible character LCDs. This class only knows what commands to send to the LCD, and not how to get them to the LCD. It is expected that a derived class will implement the hal_xxx functions. \u0026#34;\u0026#34;\u0026#34; # The following constant names were lifted from the avrlib lcd.h # header file, however, I changed the definitions from bit numbers # to bit masks. # # HD44780 LCD controller command set LCD_CLR = 0x01 # DB0: clear display LCD_HOME = 0x02 # DB1: return to home position LCD_ENTRY_MODE = 0x04 # DB2: set entry mode LCD_ENTRY_INC = 0x02 # --DB1: increment LCD_ENTRY_SHIFT = 0x01 # --DB0: shift LCD_ON_CTRL = 0x08 # DB3: turn lcd/cursor on LCD_ON_DISPLAY = 0x04 # --DB2: turn display on LCD_ON_CURSOR = 0x02 # --DB1: turn cursor on LCD_ON_BLINK = 0x01 # --DB0: blinking cursor LCD_MOVE = 0x10 # DB4: move cursor/display LCD_MOVE_DISP = 0x08 # --DB3: move display (0-\u0026gt; move cursor) LCD_MOVE_RIGHT = 0x04 # --DB2: move right (0-\u0026gt; left) LCD_FUNCTION = 0x20 # DB5: function set LCD_FUNCTION_8BIT = 0x10 # --DB4: set 8BIT mode (0-\u0026gt;4BIT mode) LCD_FUNCTION_2LINES = 0x08 # --DB3: two lines (0-\u0026gt;one line) LCD_FUNCTION_10DOTS = 0x04 # --DB2: 5x10 font (0-\u0026gt;5x7 font) LCD_FUNCTION_RESET = 0x30 # See \u0026#34;Initializing by Instruction\u0026#34; section LCD_CGRAM = 0x40 # DB6: set CG RAM address LCD_DDRAM = 0x80 # DB7: set DD RAM address LCD_RS_CMD = 0 LCD_RS_DATA = 1 LCD_RW_WRITE = 0 LCD_RW_READ = 1 def __init__(self, num_lines, num_columns): self.num_lines = num_lines if self.num_lines \u0026gt; 4: self.num_lines = 4 self.num_columns = num_columns if self.num_columns \u0026gt; 40: self.num_columns = 40 self.cursor_x = 0 self.cursor_y = 0 self.implied_newline = False self.backlight = True self.display_off() self.backlight_on() self.clear() self.hal_write_command(self.LCD_ENTRY_MODE | self.LCD_ENTRY_INC) self.hide_cursor() self.display_on() def clear(self): \u0026#34;\u0026#34;\u0026#34;Clears the LCD display and moves the cursor to the top left corner. \u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_CLR) self.hal_write_command(self.LCD_HOME) self.cursor_x = 0 self.cursor_y = 0 def show_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be made visible.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def hide_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be hidden.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def blink_cursor_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it blink.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR | self.LCD_ON_BLINK) def blink_cursor_off(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it no blink (i.e. be solid).\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def display_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on (i.e. unblanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def display_off(self): \u0026#34;\u0026#34;\u0026#34;Turns off (i.e. blanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL) def backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight on. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = True self.hal_backlight_on() def backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight off. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = False self.hal_backlight_off() def move_to(self, cursor_x, cursor_y): \u0026#34;\u0026#34;\u0026#34;Moves the cursor position to the indicated position. The cursor position is zero based (i.e. cursor_x == 0 indicates first column). \u0026#34;\u0026#34;\u0026#34; self.cursor_x = cursor_x self.cursor_y = cursor_y addr = cursor_x \u0026amp; 0x3f if cursor_y \u0026amp; 1: addr += 0x40 # Lines 1 \u0026amp; 3 add 0x40 if cursor_y \u0026amp; 2: # Lines 2 \u0026amp; 3 add number of columns addr += self.num_columns self.hal_write_command(self.LCD_DDRAM | addr) def putchar(self, char): \u0026#34;\u0026#34;\u0026#34;Writes the indicated character to the LCD at the current cursor position, and advances the cursor by one position. \u0026#34;\u0026#34;\u0026#34; if char == \u0026#39;\\n\u0026#39;: if self.implied_newline: # self.implied_newline means we advanced due to a wraparound, # so if we get a newline right after that we ignore it. pass else: self.cursor_x = self.num_columns else: self.hal_write_data(ord(char)) self.cursor_x += 1 if self.cursor_x \u0026gt;= self.num_columns: self.cursor_x = 0 self.cursor_y += 1 self.implied_newline = (char != \u0026#39;\\n\u0026#39;) if self.cursor_y \u0026gt;= self.num_lines: self.cursor_y = 0 self.move_to(self.cursor_x, self.cursor_y) def putstr(self, string): \u0026#34;\u0026#34;\u0026#34;Write the indicated string to the LCD at the current cursor position and advances the cursor position appropriately. \u0026#34;\u0026#34;\u0026#34; for char in string: self.putchar(char) def custom_char(self, location, charmap): \u0026#34;\u0026#34;\u0026#34;Write a character to one of the 8 CGRAM locations, available as chr(0) through chr(7). \u0026#34;\u0026#34;\u0026#34; location \u0026amp;= 0x7 self.hal_write_command(self.LCD_CGRAM | (location \u0026lt;\u0026lt; 3)) self.hal_sleep_us(40) for i in range(8): self.hal_write_data(charmap[i]) self.hal_sleep_us(40) self.move_to(self.cursor_x, self.cursor_y) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Write a command to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_sleep_us(self, usecs): \u0026#34;\u0026#34;\u0026#34;Sleep for some time (given in microseconds).\u0026#34;\u0026#34;\u0026#34; time.sleep_us(usecs) Tạo một file main.py để test: import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class import ussl as ssl # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;ESP32-001\u0026#34; MQTT_BROKER = \u0026#34;a23sutvtpz6muq-ats.iot.ap-southeast-1.amazonaws.com\u0026#34; MQTT_TOPIC = \u0026#34;test\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # Private key and certificate (paste the contents here as strings) key_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; cert_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; ca_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) ssl_params = { \u0026#39;key\u0026#39;: key_data, \u0026#39;cert\u0026#39;: cert_data, \u0026#39;cadata\u0026#39;:ca_data } client = MQTTClient( MQTT_CLIENT_ID, MQTT_BROKER, ssl=True, ssl_params=ssl_params, port=8883 ) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() timestamp = time.time() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, \u0026#34;device_id\u0026#34;: device_id, \u0026#34;timestamp\u0026#34;: timestamp }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message time.sleep(30) # Wait for 5 seconds before taking the next reading Chúng ta sẽ được kết quả như sau:\n"
},
{
	"uri": "//localhost:1313/3-store_data/3.2-create_lambda/",
	"title": "Tạo Lambda",
	"tags": [],
	"description": "",
	"content": "Chún ta sẽ tạo một lambda function để xử lý dữ liệu trước khi lưu vào DynamoDB.\n1. Tạo Lambda Function Truy cập vào Lambda trên console của AWS. Chọn Create function để tạo một lambda function mới. 2. Điền các thông tin cần thiết Function name: Tên của lambda function. Runtime: Chọn runtime cho lambda function, ở đây mình chọn Python 3.11. Sau đó chọn Create function để tạo lambda function. 3. Update role của lambda function Để lambda function có thể truy cập vào DynamoDB chúng ta cần update role của lambda function.\nChúng ta có thể click vào đây để được chuyển tới trang IAM role của lambda function. 4. Thêm policy Ở đây chúng ta sẽ thêm một policy mới cho lambda function. Ở đây để thuận chúng ta sẽ chọn policy AmazonDynamoDBFullAccess. 5. Update code cho lambda function Chúng ta sẽ update code cho lambda function như sau: import json import boto3 from botocore.exceptions import ClientError # Khởi tạo DynamoDB dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;ESP32-Temperature-Humidity\u0026#39;) def lambda_handler(event, context): try: # Lấy dữ liệu từ event device_id = event[\u0026#39;device_id\u0026#39;] temperature = event[\u0026#39;temp\u0026#39;] humidity = event[\u0026#39;humidity\u0026#39;] timestamp = event[\u0026#39;timestamp\u0026#39;] # Lưu dữ liệu vào DynamoDB response = table.put_item( Item={ \u0026#39;device_id\u0026#39;: device_id, \u0026#39;temperature\u0026#39;: temperature, \u0026#39;humidity\u0026#39;: humidity, \u0026#39;timestamp\u0026#39;: timestamp } ) print(\u0026#34;Data saved successfully:\u0026#34;, response) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Data saved successfully\u0026#39;) } except ClientError as e: print(\u0026#34;Error saving data:\u0026#34;, e) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Error saving data\u0026#39;) } except KeyError as e: print(\u0026#34;Missing key in event:\u0026#34;, e) return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Missing key in event\u0026#39;) } "
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.2-create_model/",
	"title": "Tạo model",
	"tags": [],
	"description": "",
	"content": "OK giờ chúng ta sẽ tạo model từ dữ liệu mà chúng ta đã thu thập được ở bước trước.\n1. Tạo model Chúng ta vào Sagemaker và chọn My Models sau đó chọn Create new model.\nTiếp theo chúng ta đặt tên cho model và chọn Problem type là Predictive analysis.\nVà tiến hành tạo.\n2. Chọn dataset Chúng ta chọn dataset mà chúng ta đã tạo ở bước trước.\n3. Cấu hình model Chúng ta tiến hành chọn các thông số sẽ được sử dụng cho model.\nNgoài ra chúng ta sẽ chọn các cột sẽ tiến hành dự đoán sau này.\nỞ đây chúng ta sẽ dự đoán cột Temperature.\nSau đó chúng ta tiến hành chọn Quick build để tạo model.\n4. Kết quả Chúng ta sẽ có kết quả như sau:\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.2-create_policies/",
	"title": "Tạo policy",
	"tags": [],
	"description": "",
	"content": "Tiếp theo chúng ta sẽ tạo policy cho các \u0026ldquo;\u0026ldquo;things\u0026rdquo;\u0026rdquo; mà chúng ta đã tạo ở bước trước có thể truy cập các AWS IoT Core resources.\n1. Chúng ta chọn Create a policy. 2. Điền thông tin về policy của bạn. Ở đây mình điền thông tin như sau:\nPolicy Name: Tên của policy. Plicy effect: Chúng ta chọn Allow - cho phép. Policy action: Chúng ta chọn iot:* - cho phép tất cả các action trong AWS IoT Core. Resource ARN: Chúng ta chọn All resources - cho phép tất cả các resources trong AWS IoT Core. Sau đó chúng ta chọn Create.\n3. Sau khi tạo chúng ta sẽ thấy policy của mình. 4. Tiếp theo chúng ta sẽ gắn policy này với certificate mà chúng ta đã tạo ở bước trước. Chúng ta vào Certificates và chọn Attach policy.\nChúng ta chọn policy mà chúng ta vừa tạo và chọn Attach polices.\n5. Sau khi gắn policy chúng ta sẽ thấy policy đã được gắn với certificate. "
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.3-prepare_dataset_for_predict/",
	"title": "Chuẩn bị dataset cho việc dự đoán",
	"tags": [],
	"description": "",
	"content": "Bây giờ chúng ta đã có model mà không cần phải viết 1 dòng code nào. So cool!!!\nTiếp theo chúng ta sẽ chuẩn bị dataset cho việc dự đoán dữ liệu từ model mà chúng ta đã tạo ở bước trước, ở file này chúng ta sẽ không có cột Temperature mà chúng ta sẽ dùng model để dự đoán giá trị của cột này.\n1. Chuẩn bị dataset Đây là file dataset mà chúng ta sẽ sử dụng để dự đoán giá trị của cột Temperature.\nTương tự như bước 5.1 chúng ta sẽ tạo dataset từ file CSV mà chúng ta đã chuẩn bị.\nỞ đây mình đã tạo 1 dataset mới từ file CSV với tên Predict_data\n"
},
{
	"uri": "//localhost:1313/3-store_data/",
	"title": "Lưu trữ dữ liệu",
	"tags": [],
	"description": "",
	"content": "\nVậy là chúng ta đã có dữ liệu từ thiết bị được gửi lên AWS IoT Core, tiếp theo chúng ta sẽ tìm cách lưu trữ những dự liệu này vào DynamoDB.\nỞ phần này chúng ta sẽ có các phần sau:\nTạo DynamoDB table. Tạo Rule để lưu trữ dữ liệu vào DynamoDB. Tạo lambda function để xử lý dữ liệu trước khi lưu vào DynamoDB. Tạo IoT Core Rule. "
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.3-test-client/",
	"title": "MQTT test client",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ sử dụng MQTT test client để test kết nối giữa thiết bị và AWS IoT Core.\n1. Ở màn hình console chúng ta chọn MQTT test client. Ở đây chúng ta điền thông tin topic là test và chọn Subscribe to topic.\nKéo xuống dưới chúng ta sẽ thấy một khung hiển thị message, hiện tại chúng ta chưa nhận được message nào.\nBây giờ chúng ta đang lắng nghe tất cả các message từ topic test mỗi khi có message được publish lên topic test thì chúng ta sẽ nhận được message đó.\n2. Chúng ta sẽ test bằng cách publish một message lên topic test. Chúng ta sẽ gửi một message lên topic test, với nội dung là Hello from AWS IoT console và chọn Publish.\nSau khi publish chúng ta sẽ nhận được message mà chúng ta vừa publish ở tab Subscribe to a topic.\nOK good job!\n"
},
{
	"uri": "//localhost:1313/3-store_data/3.3-create-iot_action/",
	"title": "Tạo IoT rule và action",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ tạo một IoT rule và action để gửi thông tin từ IoT Core tới Lambda function.\n1. Tạo IoT rule Truy cập vào IoT Core trên console của AWS. Chọn Message routing và chọn Rules. Chọn Create rule. 2. Điền các thông tin cần thiết Name: Tên của rule. Description: Mô tả về rule. Điền thông tin về query statement: Ở phần Set one or more actions chọn Add action. Chọn Lambda mà chúng ta đã tạo ở bước trước đó. Review lại thông tin và tiến hành tạo. Lúc này khi quay lại trang Lambda function chúng ta sẽ thấy được một trigger mới được tạo.\n"
},
{
	"uri": "//localhost:1313/4-example_data/",
	"title": "Chuẩn bị data mẫu",
	"tags": [],
	"description": "",
	"content": "Để thuận tiện và đỡ tốn thời gian cho việc chuẩn bị data, chúng ta sẽ sử dụng một số data mẫu có sẵn và tiến hàn import vào DynamoDB.\n1. Tạo S3 bucket Đầu tiên, chúng ta cần tạo một S3 bucket để lưu trữ các file data mẫu.\nSau đó chúng ta tải file data mẫu về và upload lên S3 bucket.\n2. Import data vào DynamoDB Tiếp theo, chúng ta sẽ import data từ S3 bucket vào DynamoDB.\nChúng ta vào DynamoDB và chọn Imports from S3.\nChúng ta điền thông tin như sau:\nSau đó chúng ta tiến hành import.\nVà kết quả chúng ta tạo được một table có dữ liệu mẫu.\nNhư các bạn thấy, chúng ta đã có dữ liệu mẫu trong DynamoDB.\n3. Export data từ DynamoDB Chúng ta cũng có thể export data từ DynamoDB ra file CSV để tiến hành import Dataset vào SageMaker.\nTrong mục Explore items sau khi Scan chúng ta chọn Action và chọn Download results to CSV.\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.4-test-esp32/",
	"title": "MQTT test ESP32",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ sử dụng ESP32 để test kết nối giữa thiết bị và AWS IoT Core.\n1. Đầu tiên chúng ta cần lấy thông tin về endpoint của MQTT broker. Chúng ta vào aws shell và chạy lệnh sau:\naws iot describe-endpoint Ta sẽ nhận được thông tin như sau:\nĐây là thông tin endpoint của MQTT broker mà chúng ta sẽ sử dụng để kết nối với AWS IoT Core.\n2. Ở file main.py chúng ta điền thông tin cert như sau: import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class import ussl as ssl # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;ESP32-001\u0026#34; MQTT_BROKER = \u0026#34;a23sutvtpz6muq-ats.iot.ap-southeast-1.amazonaws.com\u0026#34; MQTT_TOPIC = \u0026#34;test\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # Private key and certificate (paste the contents here as strings) key_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; cert_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; ca_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) ssl_params = { \u0026#39;key\u0026#39;: key_data, \u0026#39;cert\u0026#39;: cert_data, \u0026#39;cadata\u0026#39;:ca_data } client = MQTTClient( MQTT_CLIENT_ID, MQTT_BROKER, ssl=True, ssl_params=ssl_params, port=8883 ) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() timestamp = time.time() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, \u0026#34;device_id\u0026#34;: device_id, \u0026#34;timestamp\u0026#34;: timestamp }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message time.sleep(30) # Wait for 5 seconds before taking the next reading Khi chúng ta chạy file main.py trên ESP32 thì chúng ta sẽ thấy thông tin về nhiệt độ và độ ẩm được hiển thị trên LCD và cũng được publish lên topic test trên AWS IoT Core.\nChúng ta kiểm tra trên MQTT test client thì chúng ta sẽ thấy message được publish lên topic test.\nGood job!\nBây giờ bạn có thể đổi thông tin topic và publish message khác lên topic đó.\n"
},
{
	"uri": "//localhost:1313/3-store_data/3.4-test/",
	"title": "Test",
	"tags": [],
	"description": "",
	"content": "Có vẻ mọi thứ đã ổn bây giờ chúng ta hãy thử bật ESP32 lên và xem dữ liệu có được lưu vào DynamoDB không.\nKhi chạy ESP32, dữ liệu sẽ được gửi lên AWS IoT Core. AWS IoT Core sẽ xử lý dữ liệu và lưu vào DynamoDB. Chúng ta sẽ kiểm tra xem dữ liệu đã được lưu vào DynamoDB chưa. Như các bạn thấy, dữ liệu đã được lưu vào DynamoDB.\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.4-predict_data/",
	"title": "Tiến hành dự đoán",
	"tags": [],
	"description": "",
	"content": "Bây giờ chúng ta đã có model và dataset để dự đoán giá trị của cột Temperature.\n1. Dự đoán Chúng ta truy cập vào model mà chúng ta đã tạo ở bước trước và chọn Predict.\nỞ đây chúng ta chọn Manual\nTiếp theo chúng ta chọn dataset mà chúng ta đã chuẩn bị ở bước trước.\nVà sau đó chờ đợi kết quả.\n2. Kết quả Chúng ta sẽ có kết quả như sau:\nModel đã dự đoán giá trị của cột Temperature từ model mà chúng ta đã tạo.\n3. Lưu ý: Nếu chúng ta có dataset càng lớn và càng chi tiết thì model sẽ dự đoán chính xác hơn.\nTrong ví dụ này mình chỉ dự đoán giá trị của cột Temperature dựa vào giá trị của Humidity.\nTừ ví dụ này các bạn có thể áp dụng nó cho nhiều bài toán khác nhau.\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/",
	"title": "Sagemaker canvas",
	"tags": [],
	"description": "",
	"content": "\nĐược rồi đến phần thú vị nhất của phần lab ngày hôm nay, chúng ta sẽ sử dụng Sagemaker canvas để xây dựng mô hình machine learning mà không cần phải viết code.\n1. Tạo Sagemaker canvas Đầu tiên, chúng ta vào Sagemaker và chọn Sagemaker canvas sau đó chọn Create a SageMaker domain\nSau đó chờ đợi để AWS tạo domain cho chúng ta.\n2. Tạo user profile Tiếp theo, chúng ta cần tạo user profile để sử dụng Sagemaker canvas.\nChúng ta chọn Create user profile.\nChúng ta điền thông tin như sau:\nỞ đây chúng ta chỉ chọn Canvas.\nSau khi tạo thành công chúng ta có thể mở Sagemaker canvas.\n"
},
{
	"uri": "//localhost:1313/6-documents/",
	"title": "Kết luận và tài liệu tham khảo",
	"tags": [],
	"description": "",
	"content": "Kết luận Như vậy qua bài lab này chúng ta đã:\nHọc được cách sử dụng AWS IoT Core để nhận dữ liệu từ thiết bị. Học được cách sử dụng AWS Lambda để xử lý dữ liệu trước khi lưu vào DynamoDB. Học được cách sử dụng AWS Sagemaker Canvas để xây dựng model dự đoán. Từ bài lab này chúng ta có thể xây dựng 1 hệ thống IoT hoàn chỉnh từ việc nhận dữ liệu từ thiết bị, xử lý dữ liệu và dự đoán dữ liệu.\nTài liệu tham khảo AWS IoT Core AWS Lambda AWS Sagemaker Canvas Source code "
},
{
	"uri": "//localhost:1313/7-clear-resource/",
	"title": "Clear resources (Important)",
	"tags": [],
	"description": "",
	"content": "Đừng quên xóa các tài nguyên mà bạn đã tạo để tránh bị tính phí không cần thiết.\n1. Delete resources Xóa các tài nguyên mà bạn đã tạo trên AWS IoT Core. Xóa Rule. Xóa Topic. Xóa Thing. Xóa các tài nguyên mà bạn đã tạo trên AWS Lambda. Xóa function. Xóa các tài nguyên mà bạn đã tạo trên AWS Sagemaker Canvas. Xóa model. Stop Sagemaker domain. Xóa các tài nguyên mà bạn đã tạo trên AWS DynamoDB. Xóa table. Xóa các tài nguyên mà bạn đã tạo trên AWS S3. "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]