[
{
	"uri": "//localhost:1313/1-prepare_resource/1.1-esp34/",
	"title": "Cài đặt ESP32",
	"tags": [],
	"description": "",
	"content": "\nWOKWI Trong bài lab này, chúng ta sẽ sử dụng Wokwi để mô phỏng việc thu thập dữ liệu từ cảm biến nhiệt độ và độ ẩm DHT11 và gửi dữ liệu lên AWS IoT Core thông qua giao thức MQTT.\nSetup thiết bị Sau khi đã ta đã có tài khoản trên Wokwi, chúng ta tiến hành tạo một project mới.\nTruy cập vào trang chủ của Wokwi: https://wokwi.com/ Đăng nhập vào tài khoản của bạn. Tạo một project mới bằng cách chọn New Project. Chọn ESP32 từ danh sách các linh kiện. Chọn MicroPython. Chọn diagram.json và paste nội dung sau vào: { \u0026#34;version\u0026#34;: 1, \u0026#34;author\u0026#34;: \u0026#34;Anonymous maker\u0026#34;, \u0026#34;editor\u0026#34;: \u0026#34;wokwi\u0026#34;, \u0026#34;parts\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;wokwi-esp32-devkit-v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;esp\u0026#34;, \u0026#34;top\u0026#34;: 137.33, \u0026#34;left\u0026#34;: -18.01, \u0026#34;rotate\u0026#34;: 270, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-lcd1602\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;lcd1\u0026#34;, \u0026#34;top\u0026#34;: 18.67, \u0026#34;left\u0026#34;: 76, \u0026#34;attrs\u0026#34;: { \u0026#34;pins\u0026#34;: \u0026#34;i2c\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r1\u0026#34;, \u0026#34;top\u0026#34;: 113.34, \u0026#34;left\u0026#34;: -106.01, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r2\u0026#34;, \u0026#34;top\u0026#34;: 130.67, \u0026#34;left\u0026#34;: -106.68, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-dht22\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;dht1\u0026#34;, \u0026#34;top\u0026#34;: 182.7, \u0026#34;left\u0026#34;: 205.8, \u0026#34;attrs\u0026#34;: {} } ], \u0026#34;connections\u0026#34;: [ [ \u0026#34;esp:TX0\u0026#34;, \u0026#34;$serialMonitor:RX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;esp:RX0\u0026#34;, \u0026#34;$serialMonitor:TX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;lcd1:SCL\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:SDA\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;h-30\u0026#34;, \u0026#34;v103\u0026#34;, \u0026#34;h41\u0026#34; ] ], [ \u0026#34;lcd1:GND\u0026#34;, \u0026#34;esp:GND.1\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;h-39\u0026#34;, \u0026#34;v123\u0026#34;, \u0026#34;h31\u0026#34; ] ], [ \u0026#34;r2:2\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v1\u0026#34;, \u0026#34;h9\u0026#34; ] ], [ \u0026#34;r1:2\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h37\u0026#34; ] ], [ \u0026#34;r2:1\u0026#34;, \u0026#34;r1:1\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;r1:1\u0026#34;, \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;dht1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h-19.2\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-105.6\u0026#34; ] ], [ \u0026#34;dht1:SDA\u0026#34;, \u0026#34;esp:D15\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v9.6\u0026#34;, \u0026#34;h-38.3\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-119.01\u0026#34; ] ], [ \u0026#34;dht1:GND\u0026#34;, \u0026#34;esp:GND.2\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;v19.2\u0026#34;, \u0026#34;h-172.8\u0026#34; ] ] ], \u0026#34;dependencies\u0026#34;: {} } Kết quả: "
},
{
	"uri": "//localhost:1313/1-prepare_resource/",
	"title": "Chuẩn bị tài nguyên",
	"tags": [],
	"description": "",
	"content": "\nSơ đồ tổng quan Sơ đồ trên là sơ đồ tổng quan về bài lab này.\nESP32 sẽ thu thập thông tin về nhiệt độ và độ ẩm từ cảm biến. ESP32 sẽ gửi thông tin thu thập được lên Service AWS IoT Core thông qua giao thức MQTT với topic tương ứng, ở đây topic sẽ được chia theo cấu trúc device_id/sensor_id. Sau khi nhận được thông tin từ ESP32, AWS IoT Core sẽ gửi thông tin đó đến AWS Lambda để xử lý. AWS Lambda sẽ lưu thông tin nhận được vào DynamoDB. Sau một khoảng thời gian chúng ta sẽ sử dụng dữ liệu trong DynamoDB để import vào Amazon SageMaker Canvas để vẽ biểu đồ và dự đoán nhiệt độ và độ ẩm. Thông tin về resourre Toàn bộ thông tin setup wokwi và code mình sẽ để ở đây: Tài nguyên\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.1-register_new_thing/",
	"title": "Đăng kí thiết bị",
	"tags": [],
	"description": "",
	"content": "Bước đầu tiên để sử dụng AWS IoT Core là chúng ta cần đăng kí một thiết bị. Trong trường hợp của chúng ta thì đó là ESP32.\n1. Chúng ta tuy cập vào AWS IoT Core và chọn Create thing. 2. Điền thông tin về thiết bị của bạn. Ở đây mình điền thông tin như sau: Ở đây ngoài tên thì còn có nhiều thông tin khác như:\nThing type: Loại thiết bị. Thing group: Nhóm thiết bị. Billing group: Nhóm thanh toán. Packages and versions: Phiên bản và gói. Những thông tin này sẽ giúp bạn quản lý thiết bị của mình một cách dễ dàng hơn trong trường hợp bạn có nhiều thiết bị.\nỞ đây mình điền tên thiết bị + mã số thiết bị.\nSau đó các bạn chọn Next.\n3. Tạo Certificates. Để đảm bảo thông tin gửi đi và nhận về an toàn, chúng ta cần tạo Certificates cho thiết bị.\nỞ đây mình chọn Auto-generate a new certificate và chọn Next.\n4. Attach a policy. Chúng ta sẽ tạo policy sau, ở bước này chúng ta chọn Create thing\n5. Sau khi tạo chúng ta hãy tải các file Certificates về máy. "
},
{
	"uri": "//localhost:1313/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Dự Đoán Nhiệt Độ \u0026amp; Độ Ẩm Từ Dữ Liệu ESP32 qua IoT Core 1. Overview Trong bài viết này, chúng ta sẽ tìm hiểu cách sử dụng ESP32 để đo nhiệt độ và độ ẩm từ cảm biến nhiệt độ, độ ẩm, sau đó gửi dữ liệu lên AWS IOT CORE và lưu trữ vào DynamoDB. Sau đó chúng ta sẽ dùng Lambda để chuẩn hóa dữ liệu. Cuối cùng, chúng ta sẽ sử dụng AWS SageMaker Canvas để tiến hành dự đoán nhiệt độ và độ ẩm trong tương lai.\nBài Lab này có thể ứng dụng trong nhiều lĩnh vực như: nông nghiệp, y tế, công nghiệp, \u0026hellip;\n2. Objectives Hiểu cách sử dụng ESP32 để đo nhiệt độ và độ ẩm từ cảm biến nhiệt độ, độ ẩm Hiểu cách gửi dữ liệu lên AWS IOT CORE và lưu trữ vào DynamoDB Hiểu cách sử dụng Lambda để chuẩn hóa dữ liệu Hiểu cách sử dụng AWS SageMaker Canvas để tiến hành dự đoán nhiệt độ và độ ẩm trong tương lai 3. Content 1. Chuẩn bị các tài nguyên cần thiết 2. Cài đặt ESP32 3. Gửi dữ liệu lên AWS IOT CORE 4. Lưu trữ dữ liệu vào DynamoDB 5. Chuẩn hóa dữ liệu bằng Lambda 6. Dự đoán nhiệt độ và độ ẩm bằng SageMaker Canvas 7. Kết luận và xóa các service "
},
{
	"uri": "//localhost:1313/2-aws_iot_core/",
	"title": "AWS IoT Core",
	"tags": [],
	"description": "",
	"content": "\nAWS IoT Core là một service cung cấp các dịch vụ cho phép kết nối các thiết bị IoT với các service khác của AWS.\nIoT Core hỗ trợ nhiều giao thức kết nối khác nhau như:\n1. MQTT (Message Queuing and Telemetry Transport)\n2. MQTT over WSS (Websockets Secure)\n3. WebSockets\n4. HTTPS (Hypertext Transfer Protocol - Secure)\n5. LoRaWAN (Long Range Wide Area Network)\nCách kết nối thiết bị với IoT Core:\nAWS IoT Device SDK AWS IoT Core for LoRaWAN AWS Command Line Interface (CLI) AWS IoT API AWS SDKs Ngoài ra bạn cũng có thể gửi trực tiếp message vào message broker trên AWS Console.\n"
},
{
	"uri": "//localhost:1313/1-prepare_resource/1.2-library/",
	"title": "Các thư viện cần thiết",
	"tags": [],
	"description": "",
	"content": "\nCác file code để giao tiếp với màn hình. Chúng ta tạo một file i2c_lcd.py: \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C. This was tested with: https://www.wemos.cc/product/d1-mini.html\u0026#34;\u0026#34;\u0026#34; from lcd_api import LcdApi from machine import I2C from time import sleep_ms # The PCF8574 has a jumper selectable address: 0x20 - 0x27 #DEFAULT_I2C_ADDR = 0x20 # Defines shifts or masks for the various LCD line attached to the PCF8574 MASK_RS = 0x01 MASK_RW = 0x02 MASK_E = 0x04 SHIFT_BACKLIGHT = 3 SHIFT_DATA = 4 class I2cLcd(LcdApi): \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C.\u0026#34;\u0026#34;\u0026#34; def __init__(self, i2c, i2c_addr, num_lines, num_columns): self.i2c = i2c self.i2c_addr = i2c_addr self.i2c.writeto(self.i2c_addr, bytearray([0])) sleep_ms(20) # Allow LCD time to powerup # Send reset 3 times self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(5) # need to delay at least 4.1 msec self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) # Put LCD into 4 bit mode self.hal_write_init_nibble(self.LCD_FUNCTION) sleep_ms(1) LcdApi.__init__(self, num_lines, num_columns) cmd = self.LCD_FUNCTION if num_lines \u0026gt; 1: cmd |= self.LCD_FUNCTION_2LINES self.hal_write_command(cmd) def hal_write_init_nibble(self, nibble): \u0026#34;\u0026#34;\u0026#34;Writes an initialization nibble to the LCD. This particular function is only used during initialization. \u0026#34;\u0026#34;\u0026#34; byte = ((nibble \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([1 \u0026lt;\u0026lt; SHIFT_BACKLIGHT])) def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([0])) def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Writes a command to the LCD. Data is latched on the falling edge of E. \u0026#34;\u0026#34;\u0026#34; byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((cmd \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((cmd \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) if cmd \u0026lt;= 3: # The home and clear commands require a worst case delay of 4.1 msec sleep_ms(5) def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD.\u0026#34;\u0026#34;\u0026#34; byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((data \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((data \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) Chúng ta tạo một file lcd_api.py: \u0026#34;\u0026#34;\u0026#34;Provides an API for talking to HD44780 compatible character LCDs.\u0026#34;\u0026#34;\u0026#34; import time class LcdApi: \u0026#34;\u0026#34;\u0026#34;Implements the API for talking with HD44780 compatible character LCDs. This class only knows what commands to send to the LCD, and not how to get them to the LCD. It is expected that a derived class will implement the hal_xxx functions. \u0026#34;\u0026#34;\u0026#34; # The following constant names were lifted from the avrlib lcd.h # header file, however, I changed the definitions from bit numbers # to bit masks. # # HD44780 LCD controller command set LCD_CLR = 0x01 # DB0: clear display LCD_HOME = 0x02 # DB1: return to home position LCD_ENTRY_MODE = 0x04 # DB2: set entry mode LCD_ENTRY_INC = 0x02 # --DB1: increment LCD_ENTRY_SHIFT = 0x01 # --DB0: shift LCD_ON_CTRL = 0x08 # DB3: turn lcd/cursor on LCD_ON_DISPLAY = 0x04 # --DB2: turn display on LCD_ON_CURSOR = 0x02 # --DB1: turn cursor on LCD_ON_BLINK = 0x01 # --DB0: blinking cursor LCD_MOVE = 0x10 # DB4: move cursor/display LCD_MOVE_DISP = 0x08 # --DB3: move display (0-\u0026gt; move cursor) LCD_MOVE_RIGHT = 0x04 # --DB2: move right (0-\u0026gt; left) LCD_FUNCTION = 0x20 # DB5: function set LCD_FUNCTION_8BIT = 0x10 # --DB4: set 8BIT mode (0-\u0026gt;4BIT mode) LCD_FUNCTION_2LINES = 0x08 # --DB3: two lines (0-\u0026gt;one line) LCD_FUNCTION_10DOTS = 0x04 # --DB2: 5x10 font (0-\u0026gt;5x7 font) LCD_FUNCTION_RESET = 0x30 # See \u0026#34;Initializing by Instruction\u0026#34; section LCD_CGRAM = 0x40 # DB6: set CG RAM address LCD_DDRAM = 0x80 # DB7: set DD RAM address LCD_RS_CMD = 0 LCD_RS_DATA = 1 LCD_RW_WRITE = 0 LCD_RW_READ = 1 def __init__(self, num_lines, num_columns): self.num_lines = num_lines if self.num_lines \u0026gt; 4: self.num_lines = 4 self.num_columns = num_columns if self.num_columns \u0026gt; 40: self.num_columns = 40 self.cursor_x = 0 self.cursor_y = 0 self.implied_newline = False self.backlight = True self.display_off() self.backlight_on() self.clear() self.hal_write_command(self.LCD_ENTRY_MODE | self.LCD_ENTRY_INC) self.hide_cursor() self.display_on() def clear(self): \u0026#34;\u0026#34;\u0026#34;Clears the LCD display and moves the cursor to the top left corner. \u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_CLR) self.hal_write_command(self.LCD_HOME) self.cursor_x = 0 self.cursor_y = 0 def show_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be made visible.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def hide_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be hidden.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def blink_cursor_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it blink.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR | self.LCD_ON_BLINK) def blink_cursor_off(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it no blink (i.e. be solid).\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def display_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on (i.e. unblanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def display_off(self): \u0026#34;\u0026#34;\u0026#34;Turns off (i.e. blanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL) def backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight on. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = True self.hal_backlight_on() def backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight off. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = False self.hal_backlight_off() def move_to(self, cursor_x, cursor_y): \u0026#34;\u0026#34;\u0026#34;Moves the cursor position to the indicated position. The cursor position is zero based (i.e. cursor_x == 0 indicates first column). \u0026#34;\u0026#34;\u0026#34; self.cursor_x = cursor_x self.cursor_y = cursor_y addr = cursor_x \u0026amp; 0x3f if cursor_y \u0026amp; 1: addr += 0x40 # Lines 1 \u0026amp; 3 add 0x40 if cursor_y \u0026amp; 2: # Lines 2 \u0026amp; 3 add number of columns addr += self.num_columns self.hal_write_command(self.LCD_DDRAM | addr) def putchar(self, char): \u0026#34;\u0026#34;\u0026#34;Writes the indicated character to the LCD at the current cursor position, and advances the cursor by one position. \u0026#34;\u0026#34;\u0026#34; if char == \u0026#39;\\n\u0026#39;: if self.implied_newline: # self.implied_newline means we advanced due to a wraparound, # so if we get a newline right after that we ignore it. pass else: self.cursor_x = self.num_columns else: self.hal_write_data(ord(char)) self.cursor_x += 1 if self.cursor_x \u0026gt;= self.num_columns: self.cursor_x = 0 self.cursor_y += 1 self.implied_newline = (char != \u0026#39;\\n\u0026#39;) if self.cursor_y \u0026gt;= self.num_lines: self.cursor_y = 0 self.move_to(self.cursor_x, self.cursor_y) def putstr(self, string): \u0026#34;\u0026#34;\u0026#34;Write the indicated string to the LCD at the current cursor position and advances the cursor position appropriately. \u0026#34;\u0026#34;\u0026#34; for char in string: self.putchar(char) def custom_char(self, location, charmap): \u0026#34;\u0026#34;\u0026#34;Write a character to one of the 8 CGRAM locations, available as chr(0) through chr(7). \u0026#34;\u0026#34;\u0026#34; location \u0026amp;= 0x7 self.hal_write_command(self.LCD_CGRAM | (location \u0026lt;\u0026lt; 3)) self.hal_sleep_us(40) for i in range(8): self.hal_write_data(charmap[i]) self.hal_sleep_us(40) self.move_to(self.cursor_x, self.cursor_y) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Write a command to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_sleep_us(self, usecs): \u0026#34;\u0026#34;\u0026#34;Sleep for some time (given in microseconds).\u0026#34;\u0026#34;\u0026#34; time.sleep_us(usecs) Tạo một file main.py để test: import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;micropython-weather-demo\u0026#34; MQTT_BROKER = \u0026#34;broker.mqttdashboard.com\u0026#34; MQTT_USER = \u0026#34;\u0026#34; MQTT_PASSWORD = \u0026#34;\u0026#34; MQTT_TOPIC = \u0026#34;wokwi-weather\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER, user=MQTT_USER, password=MQTT_PASSWORD) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings if message != prev_weather: print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message else: print(\u0026#34;No change\u0026#34;) time.sleep(2) Chúng ta sẽ được kết quả như sau:\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.2-create_policies/",
	"title": "Tạo policy",
	"tags": [],
	"description": "",
	"content": "Tiếp theo chúng ta sẽ tạo policy cho các \u0026ldquo;\u0026ldquo;things\u0026rdquo;\u0026rdquo; mà chúng ta đã tạo ở bước trước có thể truy cập các AWS IoT Core resources.\n1. Chúng ta chọn Create a policy. 2. Điền thông tin về policy của bạn. Ở đây mình điền thông tin như sau:\nPolicy Name: Tên của policy. Plicy effect: Chúng ta chọn Allow - cho phép. Policy action: Chúng ta chọn iot:* - cho phép tất cả các action trong AWS IoT Core. Resource ARN: Chúng ta chọn All resources - cho phép tất cả các resources trong AWS IoT Core. Sau đó chúng ta chọn Create.\n3. Sau khi tạo chúng ta sẽ thấy policy của mình. 4. Tiếp theo chúng ta sẽ gắn policy này với certificate mà chúng ta đã tạo ở bước trước. Chúng ta vào Certificates và chọn Attach policy.\nChúng ta chọn policy mà chúng ta vừa tạo và chọn Attach polices.\n5. Sau khi gắn policy chúng ta sẽ thấy policy đã được gắn với certificate. Good job!\n"
},
{
	"uri": "//localhost:1313/3-store_data/",
	"title": "Lưu trữ dữ liệu",
	"tags": [],
	"description": "",
	"content": "\nVậy là chúng ta đã có dữ liệu từ thiết bị được gửi lên AWS IoT Core, tiếp theo chúng ta sẽ tìm cách lưu trữ những dự liệu này vào DynamoDB.\nỞ phần này chúng ta sẽ có các phần sau:\nTạo DynamoDB table. Tạo Rule để lưu trữ dữ liệu vào DynamoDB. Tạo lambda function để xử lý dữ liệu trước khi lưu vào DynamoDB. Tạo IoT Core Rule. "
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.3-test-client/",
	"title": "MQTT test client",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ sử dụng MQTT test client để test kết nối giữa thiết bị và AWS IoT Core.\n1. Ở màn hình console chúng ta chọn MQTT test client. Ở đây chúng ta điền thông tin topic là test và chọn Subscribe to topic.\nKéo xuống dưới chúng ta sẽ thấy một khung hiển thị message, hiện tại chúng ta chưa nhận được message nào.\nBây giờ chúng ta đang lắng nghe tất cả các message từ topic test mỗi khi có message được publish lên topic test thì chúng ta sẽ nhận được message đó.\n2. Chúng ta sẽ test bằng cách publish một message lên topic test. Chúng ta sẽ gửi một message lên topic test, với nội dung là Hello from AWS IoT console và chọn Publish.\nSau khi publish chúng ta sẽ nhận được message mà chúng ta vừa publish ở tab Subscribe to a topic.\nOK good job!\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.4-test-esp32/",
	"title": "MQTT test ESP32",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ sử dụng ESP32 để test kết nối giữa thiết bị và AWS IoT Core.\n1. Đầu tiên chúng ta cần lấy thông tin về endpoint của MQTT broker. Chúng ta vào aws shell và chạy lệnh sau:\naws iot describe-endpoint Ta sẽ nhận được thông tin như sau:\nĐây là thông tin endpoint của MQTT broker mà chúng ta sẽ sử dụng để kết nối với AWS IoT Core.\n2. Ở file main.py chúng ta điền thông tin như sau import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class import ussl as ssl # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;ESP32-001\u0026#34; MQTT_BROKER = \u0026#34;a23sutvtpz6muq-ats.iot.ap-southeast-1.amazonaws.com\u0026#34; MQTT_TOPIC = \u0026#34;test\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # Private key and certificate (paste the contents here as strings) key_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; cert_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; ca_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) ssl_params = { \u0026#39;key\u0026#39;: key_data, \u0026#39;cert\u0026#39;: cert_data, \u0026#39;cadata\u0026#39;:ca_data } client = MQTTClient( MQTT_CLIENT_ID, MQTT_BROKER, ssl=True, ssl_params=ssl_params, port=8883 ) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings if message != prev_weather: print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message else: print(\u0026#34;No change\u0026#34;) time.sleep(2) Khi chúng ta chạy file main.py trên ESP32 thì chúng ta sẽ thấy thông tin về nhiệt độ và độ ẩm được hiển thị trên LCD và cũng được publish lên topic test trên AWS IoT Core.\nChúng ta kiểm tra trên MQTT test client thì chúng ta sẽ thấy message được publish lên topic test.\nGood job!\nBây giờ bạn có thể đổi thông tin topic và publish message khác lên topic đó.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]